// SPDX-License-Identifier: AGPL-3.0
pragma solidity ^0.8.24;

import {IOracleAggregator} from "../interfaces/IOracleAggregator.sol";
import {ISafetyAutomata} from "../interfaces/ISafetyAutomata.sol";
import {IParameterRegistry} from "../interfaces/IParameterRegistry.sol";

/// @title OracleAggregator — minimal+ (DEV42: admin mock prices for dev/staging)
/// @notice Admin-gated mock storage for devnets; NOT for mainnet usage.
///         Real aggregation to be implemented later (see ORACLE_AGGREGATOR_SPEC).
contract OracleAggregator is IOracleAggregator {
    bytes32 public constant MODULE_ID = keccak256("ORACLE");

    // Dependencies
    ISafetyAutomata public immutable safety;
    IParameterRegistry public registry;

    // Admin
    address public admin;

    // Mock Storage (DEV/STAGING ONLY)
    mapping(address => Price) private _mockPrice;

    /// @notice Normalized median price in 18 decimals (WAD).
    /// @dev Updated whenever a mock price is set. Used for legacy integrations
    ///      that relied on the historic `getMedianPrice()` view.
    uint256 public lastPrice;
    /// @notice Asset address associated with the latest median snapshot.
    address public lastPriceAsset;
    /// @notice Source decimals captured when computing `lastPrice`.
    uint8 public lastPriceDecimals;

    // Events
    event AdminChanged(address indexed oldAdmin, address indexed newAdmin);
    event RegistryUpdated(address indexed oldRegistry, address indexed newRegistry);
    event OracleUpdated(address indexed asset, int256 price, uint8 decimals, bool healthy, uint256 updatedAt);

    // Errors
    error ACCESS_DENIED();
    error PAUSED();
    error ZERO_ADDRESS();
    error NEGATIVE_PRICE();
    error DECIMALS_OUT_OF_RANGE();

    constructor(address _admin, ISafetyAutomata _safety, IParameterRegistry _registry) {
        if (_admin == address(0)) revert ZERO_ADDRESS();
        if (address(_safety) == address(0)) revert ZERO_ADDRESS();
        if (address(_registry) == address(0)) revert ZERO_ADDRESS();

        admin = _admin;
        safety = _safety;
        registry = _registry;

        emit AdminChanged(address(0), _admin);
        emit RegistryUpdated(address(0), address(_registry));
    }

    // === SAFETY AUTOMATA INTEGRATION (nach Konstruktor eingefügt) ===
    ISafetyAutomata public safetyAutomata;

    function isOperational() public view returns (bool) {

        return address(safetyAutomata) != address(0) && !safetyAutomata.isPaused(keccak256("ORACLE"));
    }

    modifier whenOperational() {
        require(isOperational(), "OracleAggregator: paused by Automata");
        _;
    }
}

    // --- Mock getPrice implementation (for testing) ---
    struct Price {
        uint256 value;
        uint8 decimals;
        bool valid;
    }

    function getPrice(address asset) external view returns (Price memory p) {
        // return a static mock value for testing
        p = Price({value: 1e18, decimals: 18, valid: true});
    }

    // --- Mock updatePrice (for testing) ---
    event PriceUpdated(address indexed asset, uint256 price);

    function updatePrice(address asset, uint256 price) external whenOperational {
        emit PriceUpdated(asset, price);
    }
