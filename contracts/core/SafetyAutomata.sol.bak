// SPDX-License-Identifier: MIT
pragma solidity ^0.8.30;

import {AccessControl} from "@openzeppelin/contracts/access/AccessControl.sol";
import {ISafetyAutomata} from "../interfaces/ISafetyAutomata.sol";

/// @title SafetyAutomata
/// @notice Guardian/DAO-controlled pause switch per module (e.g., PSM, Vault, Registry).
contract SafetyAutomata is AccessControl, ISafetyAutomata {
    // Roles
    bytes32 public constant ADMIN_ROLE    = keccak256("ADMIN_ROLE");
    bytes32 public constant GUARDIAN_ROLE = keccak256("GUARDIAN_ROLE");
    bytes32 public constant DAO_ROLE      = keccak256("DAO_ROLE");
    bytes32 public constant GLOBAL_MODULE = keccak256("GLOBAL_MODULE");

    /// @notice Timestamp after which the guardian can no longer pause new modules.
    uint256 public immutable guardianSunset;

    /// @dev Pause state per moduleId (true => paused).
    mapping(bytes32 => bool) private _paused;

    /// @notice Emitted when a module is paused.
    event Paused(bytes32 indexed moduleId, address indexed by);

    /// @notice Emitted when a module is resumed.
    event Resumed(bytes32 indexed moduleId, address indexed by);

    /// @notice Reverts when a guardian action is attempted after sunset.
    error GuardianExpired();

    /// @param admin Address receiving DEFAULT_ADMIN_ROLE and ADMIN_ROLE.
    /// @param guardianSunsetTimestamp UNIX timestamp when guardian powers sunset.
    constructor(address admin, uint256 guardianSunsetTimestamp) {
        // Auto-grant GUARDIAN_ROLE to deployer for Guardian control linkage
        _grantRole(GUARDIAN_ROLE, msg.sender);
        _grantRole(DEFAULT_ADMIN_ROLE, admin);
        _grantRole(ADMIN_ROLE, admin);
        guardianSunset = guardianSunsetTimestamp;
    }

    // ------------------------------------------------------------------------
    // View API (Interface)
    // ------------------------------------------------------------------------

    /// @inheritdoc ISafetyAutomata
    function isPaused(bytes32 moduleId) external view override returns (bool) {
        return _paused[moduleId];
    }

    /// @notice Convenience inverse of isPaused (not part of the interface).
    function isModuleEnabled(bytes32 moduleId) external view returns (bool) {
        return !_paused[moduleId];
    }

    /// @inheritdoc ISafetyAutomata
    function globalPause()
        external
        view
        override(ISafetyAutomata)
        returns (bool)
    {
        // nutzt denselben Speicher wie das globale Pausen-Modul
        return _paused[keccak256("GLOBAL_MODULE")];
    }


    // ------------------------------------------------------------------------
    // Control API

    // --- Events for Guardian & external observers ---
    event ModulePaused(bytes32 indexed module, address indexed by, uint256 atBlock);
    event ModuleResumed(bytes32 indexed module, address indexed by, uint256 atBlock);

    // ------------------------------------------------------------------------

    /// @notice Pause a specific module. Guardian may do so only before sunset.
    /// @dev DAO/ADMIN can also pause if desired; restrict to GUARDIAN_ROLE until sunset else ADMIN/DAO.

    /// @notice Pause a specific module. Guardian/DAO/Admin by role.
    function pauseModule(bytes32 moduleId) external override {
        _pauseModule(moduleId, msg.sender);
        emit ModulePaused(moduleId, msg.sender, block.number);
    }

    /// @notice Unpause a specific module. Interface compat for Guardian.
    function unpauseModule(bytes32 moduleId) external override {
        _resumeModule(moduleId, msg.sender);
        emit ModuleResumed(moduleId, msg.sender, block.number);
    }

    function resumeModule(bytes32 moduleId) external {
        _resumeModule(moduleId, msg.sender);
    }

    /// @notice Backwards-compatible global pause wrapper (pauses GLOBAL_MODULE).
    function pause() external {
        _pauseModule(GLOBAL_MODULE, msg.sender);
    }

    /// @notice Backwards-compatible global unpause wrapper (resumes GLOBAL_MODULE).
    function unpause() external {
        _resumeModule(GLOBAL_MODULE, msg.sender);
    }

    /// @notice Backwards-compatible helper mirroring legacy setPaused(bool) APIs.
    function setPaused(bool state) external {
        if (state) {
            _pauseModule(GLOBAL_MODULE, msg.sender);
        } else {
            _resumeModule(GLOBAL_MODULE, msg.sender);
        }
    }

    function _pauseModule(bytes32 moduleId, address actor) internal {
        _assertPauseAuth(actor);
        _setPaused(moduleId, true, actor);
    }

    function _resumeModule(bytes32 moduleId, address actor) internal {
        _assertResumeAuth(actor);
        _setPaused(moduleId, false, actor);
    }

    function _assertPauseAuth(address actor) internal view {
        if (hasRole(GUARDIAN_ROLE, actor)) {
            if (block.timestamp >= guardianSunset) revert GuardianExpired();
        } else {
            require(
                hasRole(ADMIN_ROLE, actor) || hasRole(DAO_ROLE, actor),
                "ACCESS_DENIED"
            );
        }
    }

    function _assertResumeAuth(address actor) internal view {
        require(
            hasRole(ADMIN_ROLE, actor) || hasRole(DAO_ROLE, actor),
            "ACCESS_DENIED"
        );
    }

    function _setPaused(bytes32 moduleId, bool paused_, address actor) internal {
        _paused[moduleId] = paused_;
        if (paused_) {
            emit Paused(moduleId, actor);
        } else {
            emit Resumed(moduleId, actor);
        }
    }

}
