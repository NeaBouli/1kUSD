diff --git a/contracts/core/BuybackVault.sol b/contracts/core/BuybackVault.sol
index 33c2811..57cafce 100644
--- a/contracts/core/BuybackVault.sol
+++ b/contracts/core/BuybackVault.sol
@@ -59,6 +59,7 @@ error INVALID_STRATEGY();
 error NO_STRATEGY_CONFIGURED();
 error NO_ENABLED_STRATEGY_FOR_ASSET();
 error BUYBACK_TREASURY_CAP_EXCEEDED();
+    error BUYBACK_TREASURY_WINDOW_CAP_EXCEEDED();
 
     IERC20 public immutable stable;
     IERC20 public immutable asset;
@@ -75,6 +76,8 @@ error BUYBACK_TREASURY_CAP_EXCEEDED();
     uint64 public buybackWindowDuration;
     uint64 public buybackWindowStart;
     uint128 public buybackWindowAccumulatedBps;
+    /// @dev Snapshot of the vault stable balance used as the basis for window BPS accounting.
+    uint256 public buybackWindowStartStableBalance;
 
     event BuybackWindowConfigUpdated(
         uint64 oldDuration,
@@ -169,7 +172,9 @@ error BUYBACK_TREASURY_CAP_EXCEEDED();
     ) external onlyDAO notPaused returns (uint256 amountAssetOut) {
         if (recipient == address(0)) revert ZERO_ADDRESS();
         if (amount1k == 0) revert ZERO_AMOUNT();
-        _checkPerOpTreasuryCap(amount1k); _checkOracleHealthGate();
+        _checkPerOpTreasuryCap(amount1k);
+        _checkBuybackWindowCap(amount1k);
+        _checkOracleHealthGate();
 
         // Vault genehmigt dem PSM, 1kUSD zu ziehen
         stable.safeIncreaseAllowance(address(psm), amount1k);
@@ -195,7 +200,31 @@ error BUYBACK_TREASURY_CAP_EXCEEDED();
         uint256 cap = (bal * capBps) / 10_000;
         if (amountStable > cap) {
             revert BUYBACK_TREASURY_CAP_EXCEEDED();
-        } } function _checkOracleHealthGate() internal view { if (!oracleHealthGateEnforced) { return; } address module = oracleHealthModule; if (module == address(0)) { revert BUYBACK_ORACLE_UNHEALTHY(); } if (!IOracleHealthModule(module).isHealthy()) { revert BUYBACK_ORACLE_UNHEALTHY(); } } // --- Views ---
+        } } 
+    /// @dev A03: Rolling window cap expressed in BPS of a snapshot treasury basis.
+    function _checkBuybackWindowCap(uint256 amountStable) internal {
+        uint64 dur = buybackWindowDuration;
+        uint16 capBps = maxBuybackSharePerWindowBps;
+        if (dur == 0 || capBps == 0) return; // disabled
+
+        uint64 start = buybackWindowStart;
+        if (start == 0 || block.timestamp >= uint256(start) + uint256(dur)) {
+            buybackWindowStart = uint64(block.timestamp);
+            buybackWindowAccumulatedBps = 0;
+            buybackWindowStartStableBalance = stable.balanceOf(address(this));
+        }
+
+        uint256 basis = buybackWindowStartStableBalance;
+        if (basis == 0) revert INSUFFICIENT_BALANCE();
+
+        // ceil(amountStable * 10_000 / basis)
+        uint256 deltaBps = (amountStable * 10_000 + (basis - 1)) / basis;
+        uint256 next = uint256(buybackWindowAccumulatedBps) + deltaBps;
+        if (next > capBps) revert BUYBACK_TREASURY_WINDOW_CAP_EXCEEDED();
+        buybackWindowAccumulatedBps = uint128(next);
+    }
+
+function _checkOracleHealthGate() internal view { if (!oracleHealthGateEnforced) { return; } address module = oracleHealthModule; if (module == address(0)) { revert BUYBACK_ORACLE_UNHEALTHY(); } if (!IOracleHealthModule(module).isHealthy()) { revert BUYBACK_ORACLE_UNHEALTHY(); } } // --- Views ---
 
 
         // --- Strategy config ---
@@ -222,6 +251,7 @@ error BUYBACK_TREASURY_CAP_EXCEEDED();
         // Reset window accounting; a later DEV-11 A03 patch will implement enforcement logic.
         buybackWindowStart = 0;
         buybackWindowAccumulatedBps = 0;
+        buybackWindowStartStableBalance = 0;
         emit BuybackWindowConfigUpdated(oldDuration, newDuration, oldCapBps, newCapBps);
     }
  function setOracleHealthGateConfig(address newModule, bool newEnforced) external onlyDAO { address oldModule = oracleHealthModule; bool oldEnforced = oracleHealthGateEnforced; if (newEnforced && newModule == address(0)) { revert ZERO_ADDRESS(); } oracleHealthModule = newModule; oracleHealthGateEnforced = newEnforced; emit BuybackOracleHealthGateUpdated(oldModule, newModule, oldEnforced, newEnforced); }
@@ -297,7 +327,9 @@ function stableBalance() external view returns (uint256) {
 
         uint256 bal = stable.balanceOf(address(this));
         if (bal < amountStable) revert INSUFFICIENT_BALANCE();
-        _checkPerOpTreasuryCap(amountStable); _checkOracleHealthGate();
+        _checkPerOpTreasuryCap(amountStable);
+        _checkBuybackWindowCap(amountStable);
+        _checkOracleHealthGate();
 
         if (strategiesEnforced) {
             if (strategies.length == 0) revert NO_STRATEGY_CONFIGURED();
