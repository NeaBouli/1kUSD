--- /dev/null
+++ b/contracts/core/CollateralVault.sol
@@
+// SPDX-License-Identifier: MIT
+pragma solidity ^0.8.30;
+
+import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
+import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
+import {AccessControl} from "@openzeppelin/contracts/access/AccessControl.sol";
+import {ISafetyAutomata} from "../interfaces/ISafetyAutomata.sol";
+
+contract CollateralVault is AccessControl {
+    using SafeERC20 for IERC20;
+
+    bytes32 public constant ADMIN_ROLE = keccak256("ADMIN_ROLE");
+    bytes32 public constant DAO_ROLE = keccak256("DAO_ROLE");
+    bytes32 public constant PSM_ROLE = keccak256("PSM_ROLE");
+
+    ISafetyAutomata public safetyAutomata;
+
+    mapping(address => bool) public supportedAssets;
+    mapping(address => uint256) public balances;
+
+    event AssetSupported(address indexed asset);
+    event AssetDeposited(address indexed asset, address indexed from, uint256 amount);
+    event AssetWithdrawn(address indexed asset, address indexed to, uint256 amount);
+    event FeesSwept(address indexed asset, address indexed treasury, uint256 amount);
+
+    error UnsupportedAsset();
+    error TransferFailed();
+    error PausedError();
+
+    modifier whenNotPaused() {
+        if (address(safetyAutomata) != address(0) && safetyAutomata.isPaused()) revert PausedError();
+        _;
+    }
+
+    constructor(address admin, address automata) {
+        _grantRole(DEFAULT_ADMIN_ROLE, admin);
+        _grantRole(ADMIN_ROLE, admin);
+        safetyAutomata = ISafetyAutomata(automata);
+    }
+
+    function addSupportedAsset(address asset) external onlyRole(ADMIN_ROLE) {
+        supportedAssets[asset] = true;
+        emit AssetSupported(asset);
+    }
+
+    function isSupportedAsset(address asset) public view returns (bool) {
+        return supportedAssets[asset];
+    }
+
+    function deposit(address asset, uint256 amount) external whenNotPaused onlyRole(PSM_ROLE) {
+        if (!supportedAssets[asset]) revert UnsupportedAsset();
+        IERC20(asset).safeTransferFrom(msg.sender, address(this), amount);
+        balances[asset] += amount;
+        emit AssetDeposited(asset, msg.sender, amount);
+    }
+
+    function withdraw(address asset, address to, uint256 amount)
+        external
+        whenNotPaused
+        onlyRole(PSM_ROLE)
+    {
+        if (!supportedAssets[asset]) revert UnsupportedAsset();
+        balances[asset] -= amount;
+        IERC20(asset).safeTransfer(to, amount);
+        emit AssetWithdrawn(asset, to, amount);
+    }
+
+    function sweepFees(address asset, address treasury) external whenNotPaused onlyRole(DAO_ROLE) {
+        uint256 bal = IERC20(asset).balanceOf(address(this)) - balances[asset];
+        if (bal > 0) {
+            IERC20(asset).safeTransfer(treasury, bal);
+            emit FeesSwept(asset, treasury, bal);
+        }
+    }
+}
